[[tokens_chapter]]
== Token


((("tokens", id="ix_10tokens-asciidoc0", range="startofrange")))Perkataan "token" berasal dari bahasa Inggeris Lama "tƒÅcen," yang bermaksud tanda atau simbol. Ia biasanya digunakan untuk merujuk kepada perkara-perkara seperti duit syiling tujuan khas yang dibuat secara peribadi yang tidak penting nilai hakiki, seperti token pengangkutan, token dobi, dan token permainan arked.

Pada masa kini, "token" yang ditadbir pada rantai blok mentakrifkan semula perkataan tersebut sebagai abstraks berdasarkan rantai blok yang boleh dimiliki dan yang mewakili aset, mata wang, atau hak akses.

Penyatuan antara perkataan "token" dan nilai yang tiada berkepentingan mempunyai banyak kaitan dengan penggunaan yang terhad ke atas token versi fizikal. Selalunya terhad kepada perniagaan, organisasi, atau lokasi tertentu, token fizikal tidak mudah ditukar dan biasanya hanya mempunyai satu fungsi. Dengan token rantai blok, sekatan-sekatan ini diangkat&#x2014;atau, lebih tepat, boleh ditakrifkan semula sepenuhnya. Banyak rantai blok menyediakan khidmat pelbagai tujuan di seluruh dunia dan boleh diniagakan antara satu sama lain atau sesama mata wang lain di pasaran kecairan seluruh dunia. Dengan hilangnya keterbatasan penggunaan dan pemilikan, sangkaan kepada "nilai tiada kepentingan" pada token juga telah berubah.

Dalam bab ini, kita melihat pelbagai kegunaan token dan bagaimana ianya dicipta. Kami juga membincangkan sifat-sifat token seperti boleh laku-tukar (fungibility) dan bersifat jati semula jadi. Akhirnya, kita meneliti piawaian dan teknologi yang mendasarinya, dan kajian dengan membina token kita sendiri.

[[kegunaan_token]]
=== Bagaimana Token Digunakan

((("tokens","uses of", id="ix_10tokens-asciidoc1", range="startofrange")))Penggunaan token yang paling jelas adalah sebagai mata wang digital peribadi. Walau bagaimanapun, mungkin hanya untuk satu penggunaan. Token boleh diprogramkan untuk berfungsi dengan pelbagai fungsi yang berbeza, selalunya bertindih. Sebagai contoh, token boleh secara serentak menyampaikan hak mengundi, hak akses, dan pemilikan sumber. Seperti yang ditunjukkan dalam senarai berikut, mata wang hanyalah "aplikasi" yang pertama:

Mata Wang:: token boleh berfungsi sebagai bentuk mata wang, dengan nilai yang ditentukan melalui perdagangan persendirian.

Sumber:: Token boleh mewakili sumber yang diperoleh atau dihasilkan dalam perkongsian ekonomi atau persekitaran perkongsian sumber; sebagai contoh, token simpanan atau CPU yang mewakili sumber yang boleh dikongsi melalui rangkaian.

Aset:: Token boleh mewakili pemilikan aset semula jadi atau sebaliknya, ketara atau tidak ketara; contohnya, emas, hartanah, kereta, minyak, tenaga, barangan permainan dalam talian, dan lain-lain lagi

Akses:: Token boleh mewakili hak akses dan memberi akses kepada harta digital atau fizikal, seperti forum perbincangan, laman sesawang eksklusif, bilik hotel, atau kereta sewa.

Ekuiti:: Token boleh mewakili ekuiti pemegang saham dalam organisasi digital (misalnya, DAO) atau entiti undang-undang (misalnya, sebuah syarikat).

Pengundian:: Token boleh mewakili hak undi dalam sistem digital atau undang-undang.

Koleksi:: Token boleh mewakili koleksi digital (misalnya, CryptoPunks) atau koleksi fizikal (misalnya, lukisan).

Identiti:: Token boleh mewakili identiti digital (misalnya, avatar) atau identiti undang-undang (misalnya, kad pengenalan kebangsaan).

Perakuan:: Token boleh mewakili pensijilan atau pengesahan fakta oleh beberapa pihak berkuasa atau oleh sistem reputasi yang bukan terpusat (misalnya, rekod perkahwinan, sijil kelahiran, ijazah kolej).

Utiliti:: Token boleh digunakan untuk mengakses atau membayar perkhidmatan.

Selalunya, satu token merangkumi beberapa fungsi ini. Kadang-kadang sukar untuk membezakan di antaranya, kerana kesamaan fizikal sentiasa dikaitkan. Sebagai contoh, di dunia fizikal, lesen pemandu (pengesahan) juga merupakan identiti dokumen (identiti) dan kedua-duanya tidak boleh dipisahkan. Dalam bidang digital, fungsi yang diperkenalkan sebelum ini boleh dipisahkan dan dibangunkan secara berasingan (misalnya, pengesahan tanpa nama). (((range="endofrange", startref="ix_10tokens-asciidoc1")))

[[tokens_fungibility]]
=== Token dan Boleh Tukar-Laku

((("fungible tokens", seealso="ERC20 token standard")))((("tokens","fungibility")))https://en.wikipedia.org/wiki/Fungibility[Wikipedia] tertulis, "Dalam bidang ekonomi, kekayaan adalah harta yang baik atau komoditi yang unit individunya boleh ditukar ganti."

Token adalah boleh tukar-laku (fungible) di mana kita boleh menggantikan mana-mana satu unit token untuk yang lain tanpa sebarang perbezaan nilai atau fungsinya.

Sebenarnya, jika asal-usul sejarah token dapat dikesan, maka ianya tidak sepenuhnya boleh laku. Keupayaan menjejaki asal usul dapat menyebabkan disenarai hitam dan putih, mengurangkan atau menghapuskan bolehnya tukar-laku.

((("non-fungible tokens (NFTs)")))Token tidak laku adalah token yang masing-masing mewakili barangan ketara atau tidak ketara yang unik dan oleh itu, ianya tidak boleh ditukar ganti. Sebagai contoh, token yang mewakili pemilikan lukisan Van Gogh khusus tidak sama dengan token lain yang mewakili Picasso, walaupun ia mungkin sebahagian daripada sistem "token pemilikan seni" yang sama. Begitu juga, token yang mewakili koleksi digital khusus seperti CryptoKitty tidak boleh ditukar dengan CryptoKitty yang lain. Setiap token tidak laku ini, dikaitkan dengan pengecam tersendiri, seperti nombor siri.

Kita akan melihat contoh-contoh kedua-dua token boleh tukar-laku (fungible) dan tidak laku (fungible) dalam bab ini kemudian.

[NOTA]
====
Perhatikan bahawa "fungible" sering digunakan untuk bermaksud "secara langsung boleh ditukar dengan wang" (sebagai contoh, token kasino boleh "ditunaikan" sementara token dobi biasanya tidak boleh). Inilah pengertuan _tidak_ yang kita menggunakan perkataannya di sini.
====

[[counterparty_risk]]
=== Risiko Rakaniaga

((("counterparty risk")))((("tokens","counterparty risk")))Risiko rakan niaga adalah risiko bahawa pihak lain dalam urus niaga gagal memenuhi kewajiban mereka. Sesetengah jenis urus niaga mengalami risiko rakan niaga tambahan kerana terdapat lebih daripada dua pihak terlibat. Sebagai contoh, jika anda memegang sijil deposit untuk logam berharga dan anda menjualnya kepada seseorang, terdapat sekurang-kurangnya tiga pihak dalam transaksi itu: penjual, pembeli, dan penjaga logam berharga. Seseorang memegang aset fizikal; dengan keperluan mereka menjadi pihak kepada pemenuhan transaksi dan menambah risiko pihak yang satu lagi untuk sebarang transaksi yang melibatkan aset tersebut. Pada umumnya, apabila aset didagangkan secara tidak langsung melalui pertukaran tanda hak milik, terdapat risiko pihak lain dari pihak penjaga aset. Adakah mereka mempunyai aset? Adakah mereka akan mengesahkan (atau membenarkan) pemindahan pemilikan berdasarkan pemindahan token (seperti sijil, surat perjanjian, tajuk, atau token digital)? Dalam dunia token digital yang mewakili aset, seperti dalam dunia bukan digital, adalah penting untuk memahami siapa yang memegang aset yang diwakili oleh token dan peraturan apa yang dikenakan kepada aset yang didasari itu.

[[tokens_intrinsicality]]
=== Token dan Hakikatnya

((("tokens","intrinsicality")))Perkataan "intrinsik" berasal dari bahasa Latin "intra," yang bermaksud "dari dalam"

Sesetengah token mewakili barangan digital yang hakiki kepada rantai blok. Aset digital yang ditadbir oleh peraturan kesepakatan, sama seperti tokennya sendiri. Ini mempunyai implikasi yang penting: token yang mewakili aset hakiki tidak membawa risiko rakan niaga tambahan. Jika anda memegang kunci untuk CryptoKitty, tidak ada pihak lain yang memegang CryptoKitty untuk anda&#x2014;bahkan anda sendiri mengurusnya. Peraturan kesepakatan rantai blok berlaku dan pemilikan anda (iaitu kawalan) kunci peribadi bersamaan dengan pemilikan aset, tanpa sebarang perantara.

Sebaliknya, banyak token digunakan untuk mewakili benda-benda yang jelas, seperti hartanah, saham mengundi korporat, tanda dagangan, dan jongkong emas. Pemilikan barang-barang ini, yang tidak "terkandung" dalam rantai blok, ditadbir oleh peraturan, kebiasaan dan polisi, terpisah dari aturan kesepakatan yang mengawal token itu. Dengan kata lain, penerbit dan pemilik token masih boleh bergantung kepada kontrak bukan pintar dunia sebenar. Akibatnya, aset hakiki ini membawa risiko rakan niaga tambahan kerana mereka dipegang oleh wali, direkodkan dalam pendaftaran luaran, atau dikawal oleh undang-undang dan dasar di luar persekitaran rantai blok.

Salah satu ramalan yang paling penting bagi token berasaskan rantai blok adalah keupayaan untuk menukar aset hakiki ke dalam aset dalaman dan dengan demikian menghapuskan risiko rakan niaga. Contoh yang baik ialah, pindahkan dari ekuiti perbadanan (ekstrinsik) ke ekuiti atau token undian dalam _DAO_ atau organisasi (intrinsik) yang sama.

[[using_tokens]]
=== Menggunakan Token: Utiliti atau Ekuiti

((("tokens","utility/equity types", id="ix_10tokens-asciidoc2", range="startofrange")))Hampir semua projek dalam Ethereum hari ini dilancarkan dengan beberapa jenis token. Tetapi adakah semua projek ini benar-benar memerlukan token? Adakah terdapat kelemahan untuk menggunakan token, atau akan kita lihat slogan "pentokenan semua perkara" datang membuahkan hasil? Pada prinsipnya, penggunaan token dapat dilihat sebagai alat pengurusan atau organisasi utama. Dalam praktiknya, penyepaduan platform rantai blok, termasuk Ethereum, ke dalam struktur masyarakat yang sedia ada bermaksud bahawa, setakat ini terdapat banyak batasan untuk kegunaannya.

Mari kita mulakan dengan menjelaskan peranan token dalam projek baharu. Kebanyakkan projek menggunakan token dalam salah satu daripada dua cara: sama ada sebagai "token utiliti" atau sebagai "token ekuiti. Kebiasaannya, kedua-dua peranan itu dikekang.

((("utility tokens","defined")))Token utiliti adalah yang digunakan oleh token untuk mendapat akses kepada perkhidmatan, aplikasi, atau sumber. Contoh token utiliti termasuk token yang mewakili sumber seperti simpanan bersama, atau akses kepada perkhidmatan seperti rangkaian media sosial.

((("equity tokens","defined")))Token Ekuiti adalah yang mewakili saham dalam kawalan atau pemilikan sesuatu, seperti alat permulaan perniagaan. Token ekuiti boleh menjadi terhad sebagai saham bukan diputuskan, untuk pengedaran dividen dan keuntungan, atau sebagai saham diputuskan dalam organisasi autonomi yang bukan berpusat, di mana pengurusan platform melalui beberapa sistem tadbir urus yang rumit berdasarkan suara undi oleh pemegang token.

[[its_not_duck]]
====Bukan itik!

((("equity tokens","utility tokens as")))((("utility tokens","equity tokens disguised as")))Banyak pemula perniagaan menghadapi masalah yang sukar: iaitu token merupakan alat kerja pengumpulan dana yang hebat, tetapi, menawarkan sekuriti (ekuiti) kepada orang awam adalah aktiviti kawalselia dalam kebanyakan bidang kuasa. Dengan menyamarkan token ekuiti itu sebagai token utiliti, banyak syarikat pemula berharap dapat mengatasi sekatan kawal selia ini dan sempat mengumpul wang daripada tawaran awam sambil membentangkannya sebagai pra-jualan baucer akses perkhidmatan" atau, seperti yang kami panggil, token utiliti. Adakah penyamaran ekuiti ini akan mampu menyelamatkan diri daripada terus dilihat oleh pengawalselia.

Seperti kata pepatah Inggeris yang mahsyur: "Jika ia berjalan seperti itik dan bunyinya kwak kwak, itulah itik." Pengawal selia tidak mungkin terganggu oleh pertikaian yang penting ini; sebaliknya, mereka lebih cenderung untuk melihat hujah yang sahih sebagai cubaan untuk menipu masyarakat.

[[who_needs_utility_tokens]]
==== Token Utiliti: Siapa yang Perlu Mereka?

((("utility tokens","issues to consider when using", id="ix_10tokens-asciidoc3", range="startofrange")))Masalah sebenar ialah token utiliti mengetengahkan risiko yang jelas dan halangan penggunaan untuk pemula perniagaan. Mungkin suatu hari nanti, "pentokenan semua perkara"; akan menjadi kenyataan, tetapi pada masa ini kumpulan orang yang mempunyai pemahaman dan keinginan untuk menggunakan token adalah bahagian kecil dari pasaran matawamg kripto yang sememangnya sudah kecil.

Untuk permulaan, setiap pembaharuan mewakili risiko dan penapis pasaran. Pembaharuan adalah jalan yang singkat, perlahan-lahan menjauhi tempat asal dan tinggallah ia sendirian. Jika pemula perniagaan cuba membuat pembaharuan dalam bidang teknologi barhau, contohnya mewujudkan perkongsian penyimpanan di rangkaian P2P, itu adalah laluan yang cukup kesepian. Menambah token utiliti untuk inovasi itu dan menghendaki pengguna untuk mengambil alih token untuk menggunakan perkhidmatan itu menimbulkan risiko dan meningkatkan halangan untuk diterima pakai. Ia beransur-ansur meninggalkan inovasi penyimpanan P2P yang sudah sunyi dan ke hutan belantara.

Fikirkan setiap pembaharuan sebagai saringan. Ia menghadkan pengambilalihan kepada subset pasaran yang boleh menjadi peneraju awal inovasi ini. Menambah sebatian saringan kedua memberikannya kesan, seterusnya mengehadkan pasaran yang boleh diatasi. Anda meminta pengguna terawal untuk menerima bebannya, bukan satu tapi dua teknologi yang baharu: aplikasi/platform/perkhidmatan baharu yang anda bina, dan ekonomi token.

Untuk pemula perniagaan, setiap pembaharuan terdapat risiko yang meningkatkan peluang kegagalan permulaan. Jika anda mengambil idea permulaan anda yang berisiko dan menambah token utiliti, anda akan menambah semua risiko platform asas (Ethereum), ekonomi yang lebih luas (pengurupan, kecairan), persekitaran kawalselia (pengawal selia ekuiti/komoditi), dan teknologi (kontrak pintar, piawaian token). Betapa banyak risiko untuk permulaan.

Anjuran "pentokenan semua perkara" kemungkinan akan melawan arus dengan menggunakan token yang mereka juga mewarisi dari keghairahan pasaran, penerima awal, teknologi, inovasi, dan kecairan dari keseluruhan ekonomi token. Itu juga benar. Persoalannya ialah sama ada faedah dan keghairahan melebihi risiko dan ketidakpastian.

Walau bagaimanapun, beberapa idea perniagaan yang paling inovatif sememangnya berlaku dalam dunia kripto. Sekiranya pengawal selia tidak cukup cepat untuk mengguna pakai undang-undang dan menyokong model perniagaan baharu, usahawan dan bakat yang berkaitan akan berusaha untuk beroperasi dalam bidang kuasa lain yang lebih mesra kripto. Ini sudah pun berlaku.

Akhirnya, pada permulaan bab ini, apabila memperkenalkan token, kita membincangkan makna bahasa "token" sebagai "sesuatu yang tidak penting." Alasan yang mendasari nilai yang tidak penting bagi kebanyakan token adalah kerana ia hanya boleh digunakan dalam konteks yang terlalu sempit: satu syarikat bas, satu kedai dobi, satu arked, satu hotel, atau satu stor syarikat. Kecairan terhad, kebolehgunaan terhad, dan kos penukaran yang tinggi mengurangkan nilai token sehingga ia hanya sekadar "token" sahaja. Oleh itu, apabila anda menambah token utiliti ke platform anda, tetapi token hanya boleh digunakan pada platform tunggal anda dengan pasaran kecil, anda mencipta semula keadaan yang membuat token fizikal tidak berharga. Mungkin di sana terdapat caea cara yang betul untuk menswastakan pentokenan ke dalam projek anda. Walau bagaimanapun, jika untuk menggunakan platform anda, pengguna harus menukar sesuatu bagi mendapatkan token utiliti anda, menggunakannya, dan kemudian mengubah baki kembali ke sesuatu yang lebih umum kegunaannya, anda sebenarnya telah membuat sijil penyaksian syarikat. Kos menukar dari token digital pesanan magnitud yang lebih rendah daripada untuk token fizikal tanpa pasaran, tetapi bukannya bermaksud sifar. Token utiliti yang bekerja di seluruh sektor industri adalah sangat menarik dan mungkin agak berharga. Tetapi jika anda menetapkan permulaan anda untuk rangka kerja keseluruhan piawai industri untuk berjaya, anda mungkin telah gagal.

[NOTA]
====
Salah satu faedah menggerakkan perkhidmatan pada platform tujuan umum seperti Ethereum dapat menyambung kontrak pintar (dan utiliti token) merentas projek, meningkatkan potensi kecairan dan utiliti token.
====

((("tokens","reasons to adopt")))Jadikan keputusan ini atas sebab yang betul. Amalkanlah adanya token kerana aplikasi anda akan _gagal berfungsi tanpa token_. Amalkannya kerana token itu membuka jurang penghalang pasaran asas atau menyelesaikan masalah akses. Jangan memperkenalkan token utiliti kerana ia adalah satu-satunya cara anda boleh mengumpul wang dengan cepat yang pada akhirnya anda terpaksa berpura-pura bahawa token itu bukan jenis sekuriti bagi mengelakkan tindakan pengawalseliaan (((range = &quot;endofrange&quot;, startref = &quot;ix_10tokens-asciidoc3&quot;))). ((range = &quot;endofrange&quot;, startref = &quot;ix_10tokens-asciidoc2&quot;)))

[[token_std]]
=== Token pada Ethereum

((("tokens","on Ethereum", id="ix_10tokens-asciidoc4", range="startofrange")))Token rantai blok wujud sebelum Ethereum. ((("Bitcoin","as token")))Dalam beberapa cara, mata wang sekuriti pertama, Bitcoin, adalah token itu sendiri. Banyak platform token juga dibangunkan di Bitcoin dan matawamg kripto lain sebelum Ethereum. Walau bagaimanapun, pengenalan piawaian token pertama pada Ethereum menyebabkan ledakan pada token.

((("Buterin, Vitalik","on tokens")))Vitalik Buterin mencadangkan token sebagai salah satu aplikasi yang paling jelas dan berguna bagi suatu rantai blok yang boleh diprogramkan umum seperti Ethereum. Malah, pada tahun pertama Ethereum, adalah perkara biasa untuk melihat Vitalik dan yang lain memakai T-shirt yang diletakkan dengan logo Ethereum dan sampel kontrak pintar di bahagian belakang. Terdapat beberapa jenis T-shirt ini, tetapi yang paling umum menunjukkan pelaksanaan token.

Sebelum kita menyelidiki butir-butir membuat token di Ethereum, adalah penting untuk mempunyai gambaran keseluruhan bagaimana token berfungsi pada Ethereum. Token berbeza dari ether kerana protokol Ethereum tidak tahu apa-apa tentang mereka. Menghantar ether adalah tindakan sebahagian sifat platform Ethereum, tetapi tidak kepada pemilikan dan penghantaran token. Baki ether dalam akaun Ethereum ditangani pada tahap protokol, sedangkan token Ethereum ditangani pada tahap kontrak pintar sahaja. Untuk membuat toke  baharu pada Ethereum, anda mesti membuat kontrak pintar baharu. Sebaik sahaja digunakan, kontrak pintar mengendalikan segala-galanya, termasuk pemilikan, pemindahan, dan hak akses. Anda boleh menulis kontrak pintar anda untuk melakukan semua tindakan yang diperlukan dengan cara yang anda inginkan, tetapi lebih elok jika mengikuti piawaian yang ada. Kita akan melihat piawaian tersebut seterusnya. Kita akan membincangkan kebaikan dan keburukan piawaian berikut pada akhir bab.


[[ERC20_std]]
==== Piawaian Token ERC20

((("ERC20 token standard", id="ix_10tokens-asciidoc5", range="startofrange")))((("tokens","ERC20 standard", id="ix_10tokens-asciidoc6", range="startofrange")))Piawaian pertama diperkenalkan pada bulan November 2015 oleh Fabian Vogelsteller sebagai Permintaan Ethereum untuk Ulasan (ERC). Ia secara tidak langsung menugaskan isu GitHub nombor 20, menimbulkan nama "ERC20". Sebilangan besar token kini didasarkan pada piawaian ERC20. Permintaan ERC20 untuk ulasana akhirnya menjadi Cadangan Peningkatan Ethereum (EIP-20), tetapi kebanyakannya masih dirujuk oleh nama asal, ERC20.

ERC20 adalah piawaian untuk _token jenis laku_, yang bermaksud bahawa unit-unit yang berbeza dari token ERC20 boleh ditukar dan tidak mempunyai sifat unik.

http://bit.ly/2CUf7WG[The ERC20 standard] mentakrifkan antara muka biasa untuk kontrak yang melaksanakan token, supaya sebarang token yang serasi boleh diakses dan digunakan dengan cara yang sama. Antara muka terdiri daripada beberapa fungsi yang mesti hadir dalam setiap pelaksanaan piawai, serta beberapa fungsi dan ciri pilihan yang boleh ditambah oleh pembamgun.

[[ERC20_reqd_func]]
===== Fungsi dan peristiwa yang diperlukan oleh ERC20

((("ERC20 token standard","required functions and events")))Kontrak token yang mematuhi ERC20 mesti menyediakan sekurang-kurangnya fungsi dan peristiwa berikut:

+totalSupply+:: Mengembalikan jumlah unit token ini yang kini wujud. Token ERC20 boleh mempunyai bekalan tetap atau berubah.

+balanceOf+:: Diberi alamat, mengembalikan baki token alamat itu.

+transfer+:: Diberi alamat dan amaun, pemindahan jumlah token kepada alamat itu, dari baki alamat yang melaksanakan pemindahan itu.

+transferFrom+:: Diberi penghantar, penerima, dan jumlah, pemindahan token dari satu akaun ke akaun yang lain. Digunakan dalam kombinasi dengan +approve+.

+approve+:: Memberikan alamat dan jumlah penerima, membenarkan alamat itu untuk melaksanakan beberapa pindahan bergantung kepada jumlah itu, dari akaun yang menyiarkan kelulusan.

+allowance+:: Memberikan alamat pemilik dan alamat pembiaya, mengembalikan baki jumlah yang pembeli telah luluskan untuk dikeluarkan dari pemiliknya.

+Transfer+:: Peristiwa dicetuskan apabila pemindahan berjaya (panggilan untuk + +transfer+ atau +transferFrom+) (walaupun untuk pemindahan nilai sifar).

+Approval+:: Peristiwa didaftarkan sewaktu panggilan berjaya untuk +approve+.

[[ERC20_optional_func]]
===== Fungsi pilihan ERC20

((("ERC20 token standard","optional functions")))Sebagai tambahan kepada fungsi yang diperlukan yang disenaraikan di bahagian sebelumnya, fungsi pilihan berikut juga ditetapkan oleh piawai:

+name+:: Mengembalikan nama token yang mudah dibaca manusia (misalnya, "Dolar AS").

+symbol+:: Mengembalikan simbol yang boleh dibaca manusia (misalnya, "USD") untuk token tersebut.

+decimals+:: Mengembalikan bilangan perpuluhan yang digunakan untuk membahagikan jumlah token. Sebagai contoh, jika +decimals+ ialah +2+, maka jumlah token dibahagikan dengan 100 untuk mendapatkan pass:[<span class="keep-together">wakil</span>] penggunanya.

[[ERC20_interface]]
===== Antaramuka ERC20 ditakrifkan dalam Solidity

((("ERC20 token standard","interface defined in Solidity")))Berikut ialah bentuk khusus antara muka ERC20 seperti dalam Solidity:

[[ERC20_interface_example]]
[source,solidity]
----
contract ERC20 {
   function totalSupply() constant returns (uint theTotalSupply);
   function balanceOf(address _owner) constant returns (uint balance);
   function transfer(address _to, uint _value) returns (bool success);
   function transferFrom(address _from, address _to, uint _value) returns
      (bool success);
   function approve(address _spender, uint _value) returns (bool success);
   function allowance(address _owner, address _spender) constant returns
      (uint remaining);
   event Transfer(address indexed _from, address indexed _to, uint _value);
   event Approval(address indexed _owner, address indexed _spender, uint _value);
}
----

[[ERC20_data_struktur]]
===== struktur data ERC20

Jika anda meneliti sebarang pelaksanaan ERC20, anda akan melihat bahawa ia mengandungi dua struktur data, satu untuk mengesan baki dan satu untuk mengesan elaun. Dalam Solidity, ia dilaksanakan dengan _pemetaan data_.

Pemetaan data pertama melaksanakan jadual dalaman jadual token, oleh pemilik. Ini membolehkan kontrak token menjejaki siapa yang memiliki token tersebut. Setiap pemindahan adalah potongan dari satu baki dan tambahan kepada baki lain:

[[balance_mapping]]
[source,solidity]
----
mapping(address => uint256) balances;
----

Struktur data kedua adalah pemetaan data elaun. Seperti yang akan kita lihat di bahagian seterusnya, dengan token ERC20 pemilik token boleh mewakilkan kuasa kepada pembiaya, membenarkan mereka membelanjakan jumlah tertentu (elaun) dari baki pemilik. Kontrak ERC20 menjejaki elaun dengan pemetaan dua dimensi, dengan kunci utama menjadi alamat pemilik token, memetakan ke alamat pembiaya dan jumlah elaun:

[[allowance_mapping]]
[source,solidity]
----
mapping (address => mapping (address => uint256)) public allowed;
----


[[transfer_workflows]]
===== Aliran kerja ERC20: "transfer" dan "approve & transferFrom"

((("ERC20 token standard","transfer functions", id="ix_10tokens-asciidoc7", range="startofrange")))((("transfer function","ERC20 token standard", id="ix_10tokens-asciidoc8", range="startofrange")))Piawaian token ERC20 mempunyai dua fungsi pemindahan. Anda mungkin tertanya-tanya mengapa.

ERC20 membolehkan dua aliran kerja yang berbeza. Yang pertama adalah alur kerja tunggal langsung, menggunakan fungsi +pemindahan+. Aliran kerja ini digunakan oleh dompet untuk menghantar token kepada dompet lain. Sebilangan besar transaksi token berlaku dengan aliran kerja +transfer+.

Melaksanakan kontrak pemindahan sangat mudah. Jika Alice mahu menghantar 10 token kepada Bob, dompetnya menghantar transaksi ke alamat kontrak token, memanggil fungsi pass:[<span class="keep-together"><code>transfer</code></span>] dengan alamat Bob dan +10+ sebagai hujahnya. Kontrak token menyesuaikan baki Alice (&#x2013;10) dan baki Bob (pass:[+10]) dan mengeluarkan peristiwa +transfer+.

((("approve & transferFrom workflow")))Aliran kerja kedua adalah alur kerja dua urus niaga yang menggunakan +approve+ diikuti oleh +transferFrom+. Aliran kerja ini membolehkan pemilik token untuk mewakilkan kawalan mereka ke alamat lain. Ia paling sering digunakan untuk mewakilkan kawalan ke kontrak untuk pengedaran token, tetapi ia juga boleh digunakan oleh pengurup.

((("Initial Coin Offerings (ICOs)","tokens and")))Sebagai contoh, jika syarikat menjual token untuk ICO, mereka boleh +meluluskan+ alamat kontrak jualan jelata (crowdsale) untuk mengedarkan sejumlah token tertentu. Kontrak jualan jelata kemudiannya di +transferFrom+ dari baki pemilik kontrak token kepada setiap pembeli token, seperti digambarkan dalam <<approve_transferFrom_workflow>>;.

[NOTA]
====
((("Initial Coin Offerings (ICOs)","defined")))Penawaran Koin Permulaan (ICO) adalah alat kerja dana jelata (crowdfunding) yang digunakan oleh syarikat dan organisasi untuk mendapatkan wang dengan menjual token. Istilah ini diperolehi daripada Tawaran Awam Permulaan (IPO), yang merupakan proses di mana syarikat awam menawarkan saham untuk dijual kepada pelabur di bursa saham. Tidak seperti pasaran IPO yang dikawal selia, ICO bersifat terbuka, global, dan tidak tersusun. Contoh-contoh dan penerangan ICO dalam buku ini bukanlah pengesahan dari jenis pengumpulan dana (fundraising) ini.
====

[[approve_transferFrom_workflow]]
.Dua langkah dari alir kerja token ERC20 bagi approve & transferFrom
image::images/approve_transferFrom_workflow.png["Dua langkah dari alir kerja token ERC20 bagi approve &amp; transferFrom"]

Untuk +meluluskan+ & +pemindahan dari+ aliran kerja, dua urusniaga diperlukan. Katakan Alice ingin membenarkan kontrak +AliceICO+ untuk menjual 50% daripada semua token AliceCoin kepada pembeli seperti Bob dan Charlie. Pertama, Alice melancarkan kontrak ERC20 +AliceCoin+, mengeluarkan semua AliceCoin ke alamatnya sendiri. Kemudian, Alice melancarkan kontrak +AliceICO+ yang boleh menjual token bagi ether. Seterusnya, Alice memulakan aliran kerja +approve+ & +transferFrom+. Dia menghantar transaksi ke kontrak +AliceCoin+, memanggil +approved+ dengan alamat kontrak +AliceICO+ dan 50% daripada jumlah +totalAupply+ sebagai hujahan. Ini akan mencetuskan peristiwa +approval+. Sekarang, kontrak +AliceICO+ boleh menjual AliceCoin.

Apabila kontrak +AliceICO+ menerima ether daripada Bob, ia perlu menghantar beberapa AliceCoin kepada Bob sebagai balasannya. Dalam kontrak +AliceICO+ adalah kadar pertukaran antara AliceCoin dan ether. Kadar pertukaran yang ditetapkan Alice apabila dia membuat kontrak +AliceICO+ menentukan berapa banyak token Bob akan menerima jumlah ether yang dihantar ke kontrak +AliceICO+. Apabila kontrak +AliceICO+ memanggil fungsi transfer +AliceICO+, ia menetapkan alamat Alice sebagai penghantar dan alamat Bob sebagai penerima, dan menggunakan kadar pertukaran untuk menentukan berapa banyak token AliceCoin akan dipindahkan ke Bob dalam medan +value+. Kontrak +AliceICO+ mengalihkan baki dari alamat Alice ke alamat Bob dan mencetuskan peristiwa +Transfer+. Kontrak +AliceICO+ boleh memanggil +transferFrom+ beberapa kali tanpa had, selagi ia tidak melebihi had kelulusan yang ditetapkan Alice. Kontrak +AliceICO+ dapat menjejaki berapa banyak token AliceCoin yang boleh dijual dengan memanggil fungsi +allowance+. (((range="endofrange", startref="ix_10tokens-asciidoc8")))(((range="endofrange", startref="ix_10tokens-asciidoc7")))

[[ERC20_implementation]]
===== pelaksanaan ERC20

Walaupun ada kemungkinan untuk melaksanakan token ERC20 yang serasi dalam kira-kira 30 baris kod Solidity, kebanyakan pelaksanaannya lebih kompleks. Ini  mengambil kira kerentanan keselamatan yang bakal timbul. Terdapat dua pelaksanaan yang dinyatakan dalam piawaian EIP-20:

http://bit.ly/2EUYCMR[Consensys EIP20]:: Satu pelaksanaan mudah dan mudah dibaca suatu token ERC20 yang serasi.

https://bit.ly/2xPYck6[OpenZeppelin StandardToken]:: Pelaksanaan ini bersesuaian dengan ERC20, dengan langkah keselamatan tambahan. Ia membentuk asas pustaka OpenZeppelin yang melaksanakan token ERC20 yang lebih kompleks dengan had penmberian dana, lelongan, jadual had perlaksanaan dan ciri-ciri lain.(((range="endofrange", startref="ix_10tokens-asciidoc6")))(((range="endofrange", startref="ix_10tokens-asciidoc5")))

[[METoken_example]]
==== Pelancaran Token ERC20 Kami Sendiri

((("ERC20 token standard","METoken creation/launch example", id="ix_10tokens-asciidoc9", range="startofrange")))((("METoken (Mastering Ethereum Token)","creation/launch example", id="ix_10tokens-asciidoc10", range="startofrange")))Marilah kita cipta dan melancarkan token kita sendiri. Untuk contoh ini, kami akan menggunakan rangka kerja Truffle. Contohnya, anggaplah anda telah memasang +truffle+ dan membuat penetapannta, dan sudah biasa dengan operasi asasnya (untuk butirannya, lihat <<truffle>>).

Kami akan gelar token ini token kami "Mastering Ethereum Token,&#x201d; dengan simbol "MET".

[NOTA]
====
Anda boleh mencari contoh https://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken[in - di dalam Gudang GitHub].
====

Pertama, mari buat dan permulaan direktori projek Truffle. Jalankan empat perintah ini dan terima jawapan lalai kepada sebarang soalan:

++++
<pre data-type="programlist">
$ <strong>mkdir METoken</strong>
$ <strong>cd METoken</strong>
METoken $ <strong>truffle init</strong>
METoken $ <strong>npm init</strong>
</pre>
++++

Anda kini perlu mempunyai struktur direktori berikut:

[[truffle_directory]]
----
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
+---- truffle-config.js
`---- truffle.js
----

Sunting fail _truffle.js_ atau _truffle-config.js_ untuk menyediakan persekitaran Truffle anda, atau salinnya dari http://bit.ly/2DdP2mz[the gudang].

Jika anda menggunakan contoh _truffle-config.js_, ingat untuk membuat fail _.env_ dalam pelipat _METoken_ yang mengandungi kunci peribadi ujian anda untuk ujian dan penggunaan pada rangkaian ujian Ethereum awam, seperti Ropsten atau Kovan. Anda boleh mengeksport kunci peribadi rangkaian ujian (testnet) anda dari MetaMask.

Selepas itu direktori anda sepatutnya kelihatan seperti:

[[truffle_directory_metoken]]
----
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
+---- truffle-config.js
+---- truffle.js
`---- .env *new file*
----

[AMARAN]
====
Hanya gunakan kunci ujian atau ujian mnemonik yang _tidak_ digunakan untuk memegang dana pada rangkaian Ethereum utama. _Jangan sesekali_ menggunakan kunci yang memegang wang sebenar untuk ujian.
====

Sebagai contoh kami, kami akan mengimport perpustakaan OpenZeppelin, yang melaksanakan beberapa pemeriksaan keselamatan penting dan mudah untuk melanjutkan:

++++
<pre data-type="programlist">
$ <strong>npm install openzeppelin-solidity@1.12.0</strong>

+ openzeppelin-solidity@1.12.0
menambah 1 pakej daripada 1 penyumbang dan diaudit 2381 pakej dalam 4.074s
</pre>
++++

Pakej +openzeppelin-solidity+ akan menambah kira-kira 250 fail di bawah direktori __node_modules__. Pustaka OpenZeppelin terkandung lebih dari sekadar token ERC20, tetapi kita hanya akan menggunakan sebahagian kecil daripadanya.

Seterusnya, mari kita tulis kontrak token. Buat fail baru, _METoken.sol_, dan salin kod contoh dari http://bit.ly/2qfIFH0[GitHub].

Kontrak kita, ditunjukkan dalam <<solidity_token_example>>;, sangat mudah, kerana ia mewarisi semua fungsinya dari pustaka OpenZeppelin.

[[solidity_token_example]]
.METoken.sol: Kontrak Solidity yang melaksanakan token ERC20
====
[source,solidity,linenums]
----
include::code/truffle/METoken/contracts/METoken.sol[]
----
====

Di sini, kita menentukan pembolehubah pilihan +nama+, +simbol+, dan +perpuluhan+. Kami juga menentukan pemboleh ubah bekalan permulaan iaitu +_initial_supply+, yang ditetapkan kepada 21 juta token; dengan dua perpuluhan dibahagikan yang memberikan 2.1 bilion unit keseluruhan. Dalam fungsi awalan (pembina) kontrak, kami menetapkan +totalSupply+ menjadi sama dengan +_initial_supply+ dan memperuntukkan semua +_initial_supply+ ke baki akaun (+msg.sender+) yang mencipta kontrak +METoken+.

Kami kini menggunakan +truffle+ untuk menyusun +kod +METoken+:

++++
<pre data-type="programlist">
$ <strong>truffle compile</strong>
Compiling ./contracts/METoken.sol...
Compiling ./contracts/Migrations.sol...
Compiling openzeppelin-solidity/contracts/math/SafeMath.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol...
</pre>
++++

Seperti yang anda lihat, +truffle+ menggabungkan kebergantungan yang diperlukan dari pustaka OpenZeppelin dan menyusun kontrak itu juga.

Mari kita buat skrip penghijrahan menggunakan kontrak +METoken+. Buat fail baru yang dipanggil __2_deploy_contracts.js__, dalam pelipat _METoken/migrations_. Salin kandungan dari contoh http://bit.ly/2P0rHLl[in Gudang GitHub]:


[[METoken_migration]]
.2_deploy_contracts: Migration to deploy METoken
[source,javascript,linenums]
----
include::code/truffle/METoken/migrations/2_deploy_contracts.js[]
----

Sebelum kita menggunakan salah satu rangkaian ujian Ethereum, mari kita mulakan rantai blok setempat untuk menguji segala-galanya. Mulailah rantai blok +ganache+, sama ada dari baris arahan dengan +ganache-cli+ atau dari antara muka pengguna grafik.

Sebaik sahaja +ganache+ dimulakan, kita boleh menggunakan kontrak +METoken+ dan lihat jika semuanya berfungsi seperti yang diharapkan:

++++
<pre data-type="programlist">
$ <strong>truffle migrate --network ganache</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb2e90a056dc6ad8e654683921fc613c796a03b89df6760ec1db1084ea4a084eb
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying METoken...
  ... 0xbe9290d59678b412e60ed6aefedb17364f4ad2977cfb2076b9b8ad415c5dc9f0
  METoken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...
</pre>
++++

Pada konsol +ganache+, kita harus melihat bahawa kita telah membuat empat transaksi baru, seperti yang digambarkan di <<ganache_METoken>>.

[[ganache_METoken]]
.METoken penyebaran pada ganache
image::images/ganache_metoken.png["Penyebaran METOKEN pada Ganache"]

[[truffle_console]]
===== Berinteraksi dengan METoken menggunakan konsol Truffle

((("METoken (Mastering Ethereum Token)","interacting with via Truffle console", id="ix_10tokens-asciidoc11", range="startofrange")))((("Truffle","interacting with METoken via Truffle console", id="ix_10tokens-asciidoc12", range="startofrange")))Kita boleh bertindak balas dengan kontrak di rantai blok +ganache+ menggunakan konsol Truffle. Ini adalah persekitaran JavaScript yang interaktif yang menyediakan akses kepada persekitaran Truffle dan, melalui web3, kepada rantai blok. Dalam kes ini, kami akan menyambung konsol Truffle ke rantai blok +ganache+:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt;
</pre>
++++

Tindakan pantas +truffle(ganache)>+ menunjukkan bahawa kita disambungkan ke rantai blok +ganache+ dan bersedia untuk menaip perintah kita. Konsol Truffle menyokong semua perintah +truffle+, jadi kita boleh +menyusun+ dan +berhijrah+ dari konsol. Kami sudah menjalankan arahan itu, jadi mari pergi terus ke kontrak itu sendiri. Kontrak +METoken+ wujud sebagai objek JavaScript dalam persekitaran Truffle. Taip ++**METoken**++ pada prompt dan ia akan benamkan seluruh huraian kontrak:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken</strong>
{ [Function: TruffleContract]
  _static_methods:

[...]

currentProvider:
 HttpProvider {
   host: 'http://localhost:7545',
   timeout: 0,
   user: undefined,
   password: undefined,
   headers: undefined,
   send: [Function],
   sendAsync: [Function],
   _alreadyWrapped: true },
network_id: '5777' }
</pre>
++++

Objek +METoken+ juga memperlihatkan beberapa sifat, seperti alamat kontrak (seperti yang digunakan oleh perintah +migrate+):

++++
<pre data-type="programlist">
truffle (ganache)&gt; <strong>METoken.address</strong>
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
</pre>
++++

Jika kita mahu berinteraksi dengan kontrak yang digunakan, kita perlu menggunakan panggilan tidak segerak, dalam bentuk JavaScript iaitu "promise". Kami menggunakan fungsi +deployed+ untuk mendapatkan contoh kontrak dan kemudian memanggil fungsi +totalSupply+:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => instance.totalSupply())</strong>
BigNumber { s: 1, e: 9, c: [ 2100000000 ] }
</pre>
++++

Seterusnya, mari gunakan akaun yang dibuat oleh +ganache+ untuk memeriksa baki METoken dan hantar beberapa METoken ke alamat lain. Pertama, mari kita dapatkan alamat akaun:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>let accounts</strong>
undefined
truffle(ganache)&gt; <strong>web3.eth.getAccounts((err,res) => { accounts = res })</strong>
undefined
truffle(ganache)&gt; <strong>accounts[0]</strong>
'0x627306090abab3a6e1400e9345bc60c78a8bef57' 
</pre>
++++

Senarai +akaun+ sekarang mengandungi semua akaun yang dicipta oleh +ganache+, dan +akaun[0]+ ialah akaun yang menggunakan kontrak +METoken+. Ia sepatutnya mempunyai baki pass:[<span class="keep-together">METoken</span>], kerana pembina METoken memberikan bekalan token kepada alamat yang menciptanya. Mari semak:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =></strong>
                  <strong>{ instance.balanceOf(accounts[0]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2100000000 ] }</strong>
</pre>
++++

Finally, let's transfer 1000.00 METoken from +account[0]+ to +account[1]+, by calling the contract's +transfer+ function:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.transfer(accounts[1], 100000) })</strong>
undefined
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.balanceOf(accounts[0]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2099900000 ] }</strong>
undefined
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.balanceOf(accounts[1]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>
</pre>
++++

[PETUA]
====
METoken mempunyai 2 perpuluhan yang sama, bermakna 1 METoken adalah 100 unit dalam kontrak. Apabila kami memindahkan 1000 METoken, kami menyatakan nilai sebagai +100000+ dalam panggilan ke fungsi +transfer+.
====

Seperti yang anda lihat, di konsol, +akaun[0]+ kini mempunyai 20,999,000 MET, dan +akaun[1]+ mempunyai 1,000 MET.

Jika anda beralih ke antara muka pengguna +ganache+ bergrafik, seperti yang ditunjukkan dalam <<ganache_METoken_transfer>>;, anda akan melihat urus niaga yang memanggil fungsi +transfer+. (((range="endofrange", startref="ix_10tokens-asciidoc12")))(((range="endofrange", startref="ix_10tokens-asciidoc11")))

[[ganache_METoken_transfer]]
.METoken pemindahannya pada ganache
image::images/ganache_metoken_transfer.png["Memindahkan METoken pada Ganache"]

[[sending_erc20_tokens_contracts]]
===== Mengirim token ERC20 ke alamat kontrak

((("Faucet.sol contract (test example)","METoken project", id="ix_10tokens-asciidoc13", range="startofrange")))((("METoken (Mastering Ethereum Token)","sending to contract addresses", id="ix_10tokens-asciidoc14", range="startofrange")))Setakat ini, kami telah menyediakan token ERC20 dan memindahkan beberapa token dari satu akaun ke akaun yang lain. Semua akaun yang kami gunakan untuk pertunjukkan ini adalah akaun luaran, bermakna ia dikendalikan oleh kunci peribadi, bukan kontrak. Apa yang berlaku jika kami menghantar MET ke alamat kontrak? Mari semak!

Pertama, mari kita gunakan kontrak lain dalam persekitaran ujian ini. Untuk contoh ini, kami akan menggunakan kontrak pertama kami, _Faucet.sol_. Mari tambahkannya ke projek METoken dengan menyalinnya ke direktori _contracts_. Direktori kita sepatutnya kelihatan seperti ini:

[[METoken_directory]]
----
METoken/
+---- contracts
|   +---- Faucet.sol
|   +---- METoken.sol
|   `---- Migrations.sol
----

Kami juga akan menambah penghijrahan, untuk menggunakan +Faucet+ secara berasingan daripada +METoken+:

[[faucet_migration]]
[source,solidity]
----
var Faucet = artifacts.require("Faucet");

module.exports = function(deployer) {
  // Deploy the Faucet contract as our only task
  deployer.deploy(Faucet);
};
----

Mari kita menyusun dan memindahkan kontrak dari konsol Truffle:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt; <strong>compile</strong>
Compiling ./contracts/Faucet.sol...
Writing artifacts to ./build/contracts

truffle(ganache)&gt; <strong>migrate</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x89f6a7bd2a596829c60a483ec99665c7af71e68c77a417fab503c394fcd7a0c9
  Migrations: 0xa1ccce36fb823810e729dce293b75f40fb6ea9c9
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0x28d0da26f48765f67e133e99dd275fac6a25fdfec6594060fd1a0e09a99b44ba
  METoken: 0x7d6bf9d5914d37bcba9d46df7107e71c59f3791f
Saving artifacts...
Running migration: 3_deploy_faucet.js
  Deploying Faucet...
  ... 0x6fbf283bcc97d7c52d92fd91f6ac02d565f5fded483a6a0f824f66edc6fa90c3
  Faucet: 0xb18a42e9468f7f1342fa3c329ec339f254bc7524
Saving artifacts...
</pre>
++++

Hebat. Sekarang mari kita hantar MET ke + Faucet + kontrak:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.transfer(Faucet.address, 100000) })</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(Faucet.address).then(console.log)})</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>
</pre>
++++

Baiklah, kami telah memindahkan 1,000 MET ke kontrak +Faucet+. Sekarang, bagaimana kita hendak keluarkan token tersebut?

Ingat, _Faucet.sol_ adalah kontrak yang mudah. Ia hanya mempunyai satu fungsi, pass:[<span class="keep-together"><code>withdraw</code></span>], iaitu untuk mengeluarkan _ether_. Ia tidak mempunyai fungsi untuk mengeluarkan MET, atau sebarang token ERC20 yang lain. Jika kita menggunakan +withdraw+, ia akan cuba menghantar ether, tetapi kerana +Faucet+ tidak mempunyai baki ether lagi, ia akan gagal.

Kontrak +METoken+ tahu bahawa +Faucet+ mempunyai baki, tetapi satu-satunya cara ia dapat memindahkan baki itu adalah jika ia menerima panggilan +transfer+ dari alamat kontrak. Entah bagaimana kita perlu membuat kontrak +Faucet+ untuk memanggil fungsi transfer+ pada pass:[<span class="keep-together"><code>METoken</code></span>].

Jika anda tertanya-tanya apa yang perlu dilakukan seterusnya, nanti dulu. Tiada penyelesaian untuk masalah ini. MET yang dihantar kepada +faucet+ kini terjerat, selama-lamanya. Hanya kontrak +Faucet+ boleh memindahkannya, dan kontrak +Faucet+ tidak mempunyai kod untuk memanggil fungsi +pemindahan+ kontrak token ERC20.

Mungkin anda menjangkakan masalah ini. Kemungkinan besar, anda tidak. Malah, tidak ada ratusan pengguna Ethereum yang secara tidak sengaja memindahkan pelbagai token kepada kontrak yang tidak mempunyai keupayaan ERC20. Mengikut beberapa anggaran, token bernilai lebih daripada kira-kira $ 2.5 juta USD (pada masa penulisan) telah "terjebak" seperti ini dan akan hilang selama-lamanya.

Salah satu cara yang pengguna token ERC20 boleh secara tidak sengaja kehilangan token mereka dalam pemindahan, adalah apabila mereka cuba untuk memindahkan ke pengurupan atau perkhidmatan lain. Mereka menyalin alamat Ethereum dari laman web pertukaran, memikirkan mereka hanya boleh menghantar token kepadanya. Walau bagaimanapun, banyak pengurup menerbitkan alamat yang menerima kontrak! Kontrak ini hanya dimaksudkan untuk menerima etherr, bukan token ERC20, yang sering menyapu semua dana yang dihantar kepada mereka ke "peti beku" atau dompet terpusat lain. Walaupun banyak amaran dinyatakan "jangan menghantar token ke alamat ini," banyak juga token yang hilang dengan cara sebegini.(((range="endofrange", startref="ix_10tokens-asciidoc14")))(((range="endofrange", startref="ix_10tokens-asciidoc13")))

[[transfer_workflow_demo]]
===== Menunjukkan &#x201c;kelulusan & pemindahan dari&#x201d; aliran kerja

((("approve & transferFrom workflow", id="ix_10tokens-asciidoc15", range="startofrange")))((("Faucet.sol contract (test example)","METoken approve & transferFrom workflow demonstration", id="ix_10tokens-asciidoc16", range="startofrange")))((("METoken (Mastering Ethereum Token)","approve & transferFrom workflow demonstration", id="ix_10tokens-asciidoc17", range="startofrange")))Kontrak +Faucet+ ini tidak dapat mengendalikan token ERC20. Menghantar token kepadanya menggunakan fungsi +pemindahan+ mengakibatkan kehilangan token tersebut. Mari tulis semula kontrak sekarang dan supaya ia mengendalikan token ERC20. Khususnya, kami akan mengubahnya menjadi faucet yang memberi MET kepada sesiapa yang meminta.

Untuk contoh ini, kami akan membuat salinan direktori projek _truffle_ (kami akan memanggilnya __METoken_METFaucet__), memulakan +truffle+ dan +npm+, pasangkan kebergantungan OpenZeppelin, dan salin kontrak _METoken.sol_. Lihat contoh pertama kami, dalam <<METoken_example>>, untuk arahan terperinci.

Kontrak faucet baharu kami, _METFaucet.sol_, akan kelihatan seperti <<METFaucet>>.

[[METFaucet]]
.METFaucet.sol: A faucet for METoken
====
[source,solidity,linenums]
----
include::code/truffle/METoken_METFaucet/contracts/METFaucet.sol[]
----
====

Kami telah membuat sedikit perubahan kepada contoh asas +Faucet+. Oleh kerana +METFaucet+ akan menggunakan fungsi +transferFrom+ dalam +METoken+, ia memerlukan dua pembolehubah tambahan. Satu akan memegang alamat kontrak +METoken+ yang digunakan. Yang lain akan memegang alamat pemilik MET, yang akan meluluskan pengeluaran faucet. Kontrak +METFaucet+ akan memanggil +METoken.transferFrom+ dan mengarahkannya untuk memindahkan MET dari pemilik ke alamat tempat dari mana permintaan pengeluaran faucet itu datang.


Kami mengisytiharkan kedua-dua pemboleh ubah ini di sini:

[source,solidity]
----
StandardToken public METoken;
address public METOwner;
----

Oleh kerana faucet ini perlu dimulakan dengan alamat yang betul untuk +METoken+ dan +METOwner+, kita perlu mengisytiharkan pembina tersuai:

[[custom_constructor]]
[source,solidity]
----
// METFaucet constructor - membekalkan alamat kontrak METoken dan
// alamat pemilik kita akan luluskannya ke transferFrom
function METFaucet(address _METoken, address _METOwner) public {

	// Memulakan METoken dari alamat yang dibekalkan
	METoken = StandardToken(_METoken);
	METOwner = _METOwner;
}
----

Perubahan seterusnya adalah untuk fungsi +pengeluaran+. Berbanding memanggil +transfer+, +METFaucet+ menggunakan fungsi +transferFrom+ dalam +METoken+ dan meminta +METoken+ untuk memindahkan MET ke penerima faucet:

[[transfer_met]]
[source,solidity]
----
// Gunakan fungsi transferForm METoken
METoken.transferFrom (METOwner, msg.sender, withdraw_amount);
----

Akhir sekali, memandangkan faucet ini tidak lagi menghantar ether, kita berkemungkinan menghalang sesiapa daripada menghantar ether ke +METFaucet+, kerana kita tidak mahu ia tersekat. Kami mengubah fungsi bayar balik untuk menolak kemasukan ether, menggunakan fungsi +revert+ untuk memulihkan pembayaran masuk:

[[reject_incoming_eth]]
[source,solidity]
----
// SEKAT semua jenis ether
function () external payable { revert(); }
----

Sekarang kod _METFaucet.sol_ kami siap, kami perlu mengubah suai skrip pemindahan untuk menggunakannya. Skrip penghijrahan ini akan menjadi lebih kompleks, seperti +METFaucet+ bergantung pada alamat +METoken+. Kami akan menggunakan akujanji JavaScript untuk menggunakan kedua-dua kontrak secara berturut-turut. Buat __2_deploy_contracts.js__ seperti berikut:

[source,solidity]
----
var METoken = artifacts.require("METoken");
var METFaucet = artifacts.require("METFaucet");
var owner = web3.eth.accounts[0];

module.exports = function(deployer) {

	// Lancarkan kontrak METoken dahulu
	deployer.deploy(METoken, {from: owner}).then(function() {
		// Kemudian lancarkan METFaucet dan serah alamat METoken serta
		// alamat pemilik yang meluluskan semua MET METFaucet
		return deployer.deploy(METFaucet, METoken.address, owner);
  	});
}
----

Kini, kita boleh menguji segala-galanya dalam konsol Truffle. Pertama, kami menggunakan +migrate+ untuk menggerakkan kontrak. Apabila +METoken+ digunakan maka ia akan memperuntukkan semua MET ke akaun yang menciptanya, +web3.eth.accounts[0]+. Kemudian, kami memanggil fungsi +approve+ pass:[<code><span class="keep-together">METoken</span></code>] untuk meluluskan +METFaucet+ untuk menghantar sehingga 1,000 MET bagi pihak +web3.eth.accounts[0]+. Akhirnya, untuk menguji faucet ini, kami panggil +METFaucet.withdraw+ dari +web3.eth.accounts[1]+ dan cuba mengeluarkan 10 MET. Berikut adalah perintah konsol:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt; <strong>migrate</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x79352b43e18cc46b023a779e9a0d16b30f127bfa40266c02f9871d63c26542c7
  Migrations: 0xaa588d3737b611bafd7bd713445b314bd453a5c8
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0xc42a57f22cddf95f6f8c19d794c8af3b2491f568b38b96fef15b13b6e8bfff21
  METoken: 0xf204a4ef082f5c04bb89f7d5e6568b796096735a
  Replacing METFaucet...
  ... 0xd9615cae2fa4f1e8a377de87f86162832cf4d31098779e6e00df1ae7f1b7f864
  METFaucet: 0x75c35c980c0d37ef46df04d31a140b65503c0eed
Saving artifacts...
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.approve(METFaucet.address, 100000) })</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 0, c: [ 0 ] }</strong>
truffle(ganache)&gt; <strong>METFaucet.deployed().then(instance =>
                  { instance.withdraw(1000, {from:web3.eth.accounts[1]}) } )</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 3, c: [ 1000 ] }</strong>
</pre>
++++

Seperti yang anda dapat lihat dari hasil, kita boleh menggunakan aliran kerja +approve+ &amp; +transferFrom+ workflow untuk membenarkan satu kontrak memindahkan token yang ditakrifkan dalam token lain. Sekiranya digunakan dengan betul, token ERC20 boleh digunakan oleh EOA dan kontrak lain.

Walau bagaimanapun, beban pengurusan token ERC20 dengan betul ditolak kepada antara muka pengguna. Jika pengguna salah cuba untuk memindahkan token ERC20 ke alamat kontrak dan kontrak itu tidak dilengkapi untuk menerima token ERC20, token akan hilang(((range="endofrange", startref="ix_10tokens-asciidoc17")))(((range="endofrange", startref="ix_10tokens-asciidoc16")))(((range="endofrange", startref="ix_10tokens-asciidoc15"))).(((range="endofrange", startref="ix_10tokens-asciidoc10")))(((range="endofrange", startref="ix_10tokens-asciidoc9")))

[[ERC20_issues]]
==== Masalah dengan Token ERC20

((("ERC20 token standard","issues with ERC20 tokens")))Penggunaan piawaian token ERC20 telah benar-benar meletup. Beribu-ribu token telah dilancarkan, sama ada mengkaji dengan keupayaan baharu dan mengumpul dana dalam pelbagai lelongan "dana jelata" dan ICO. Walau bagaimanapun, terdapat beberapa perangkap yang dijangkakan, seperti yang kita lihat dengan isu pemindahan token kepada alamat kontrak.

Salah satu isu yang kurang jelas dengan token ERC20 ialah ianya mendedahkan perbezaan halus antara token dan ether itu sendiri. Di mana ether dipindahkan oleh urus niaga yang mempunyai alamat penerima sebagai tujuannya, pemindahan token berlaku dalam _kontrak penyata token khusus_ dan mempunyai kontrak token sebagai destinasi mereka, bukan alamat penerima. Kontrak token menjejaki baki dan mengeluarkan peristiwa. Dalam pemindahan token, tiada transaksi sebenarnya dihantar kepada penerima token. Sebaliknya, alamat penerima ditambah ke dalam peta dalam kontrak token itu sendiri. Transaksi penghantaran ether ke alamat mengubah penyata alamat. Transaksi yang memindahkan token ke alamat hanya mengubah penyata kontrak token, bukan keadaan alamat penerima. Malah dompet yang mempunyai sokongan untuk token ERC20 tidak menyedari baki token kecuali pengguna secara jelas menambahkan kontrak token khusus untuk "tontonan"; Sesetengah dompet menontonkan kontrak token yang paling popular untuk mengesan baki yang dipegang oleh alamat yang dikendalikannya, tetapi itu terhad kepada sebahagian kecil daripada pass:[<span class="keep-together">kontrak</span>] ERC20 sedia ada.

Malah, tidak mungkin pengguna akan mengesan semua baki dalam semua kontrak token ERC20 yang mungkin. Banyak token ERC20 lebih seperti spam e-mel daripada token berguna. Ia secara langsung membuat baki untuk akaun yang mempunyai aktiviti ether, untuk menarik perhatian pengguna. Jika anda mempunyai alamat Ethereum dengan sejarah panjang aktiviti, terutamanya jika ia dicipta di pra jualan, anda akan mendapati ia mengandungi tanda-tanda "spam" yang muncul dari mana-mana tempat. Sudah tentu, alamat itu tidak benar-benar penuh dengan token; ia adalah kontrak token yang mempunyai alamat anda di dalamnya. Anda hanya melihat baki jika kontrak token ini ditontonkan oleh penjelajah blok atau dompet yang anda gunakan untuk melihat alamat anda.

Token tidak bertindak dengan cara yang sama seperti ether. Ether dihantar dengan fungsi +send+ dan diterima oleh sebarang fungsi yang boleh dibayar dalam kontrak atau alamat luaran yang dimiliki. Token dihantar menggunakan fungsi +approve+ & +transferFrom+  yang wujud hanya dalam kontrak ERC20, dan tidak (sekurang-kurangnya dalam ERC20) mencetuskan apa-apa fungsi yang boleh dibayar dalam kontrak penerima. Token bertujuan untuk berfungsi sama seperti matawang kripto seperti ether, tetapi ia datang dengan perbezaan tertentu yang memecahkan bayangan itu.

((("gas","tokens and")))((("tokens","gas and")))Pertimbangkan satu lagi masalah. Untuk menghantar ether atau menggunakan sebarang kontrak Ethereum yang anda perlukan ether untuk membayar gas. Untuk menghantar token, _anda juga memerlukan ether_. Anda tidak boleh membayar gas transaksi dengan token dan kontrak token tidak boleh membayar gas untuk anda. Ini mungkin berubah pada satu ketika di masa depan, tetapi dalam masa yang sama ini dapat menyebabkan pengalaman janggal oleh pengguna. Sebagai contoh, katakan anda menggunakan pengurup atau ShapeShift untuk menukar beberapa bitcoin kepada token. Anda "menerima" token dalam dompet yang menjejaki kontrak token itu dan menunjukkan baki anda. Ia kelihatan sama dengan mana-mana matawang kripto lain yang anda ada dalam dompet anda. Cuba hantar token, fikirkanlah, dompet anda akan memberitahu anda bahawa anda memerlukan ether untuk melakukannya. Anda mungkin bingung&#x2014pada masa itu, padahal anda tidak perlu ether menerima token tersebut. Mungkin anda tidak mempunyai ether. Mungkin anda tidak tahu token itu adalah token ERC20 pada Ethereum; mungkin anda fikir ia adalah matawang kripto dengan rantai bloknya sendiri. Bayangan menjadi kelam.

Antara maaalah lain adalah pengkhususan untuk token ERC20. Selainnya adalah isu yang lebih umum yang berkaitan dengan abstraks dan sempadan antara muka dalam Ethereum. Ada yang boleh diselesaikan dengan menukar antara muka token, sementara yang lain mungkin memerlukan perubahan kepada struktur asas dalam Ethereum (seperti perbezaan antara EOA dan kontrak, dan antara urus niaga dan mesej). Sesetengah mungkin "tidak dapat diselesaikan" secara tepat dan mungkin memerlukan reka bentuk antara muka pengguna untuk menyembunyikan kecacatan dan membuat pengalaman pengguna menjadi teguh tanpa mengira perbezaan yang mendasarinya.

Dalam bahagian seterusnya, kita akan melihat pelbagai cadangan yang cuba menangani beberapa isu ini.

[[ERC223_std]]
==== ERC223: Satu Cadangan Piawaian Antaramuka Kontrak Token

((("ERC223 token standard proposal")))((("tokens","ERC223 standard proposal")))Lamaran pada ERC223 sebagai cubaan menyelesaikan masalah perpindahan secara tidak sengaja kepada kontrak (yang mungkin atau mungkin tidak menyokong token) dengan mengesan sama ada alamat destinasi adalah kontrak atau tidak. ERC223 memerlukan kontrak yang dirancang untuk menerima token melaksanakan fungsi bernama +tokenFallback+. Jika destinasi pemindahan adalah kontrak dan kontrak tidak mempunyai sokongan untuk token (iaitu, tidak melaksanakan +tokenFallback+), pemindahan itu gagal.

[[is_contract]]
Untuk mengesan sama ada alamat destinasi adalah kontrak, pelaksanaan rujukan ERC223 menggunakan segmen kecil kod bait varis dalaman dengan cara penghasilan yang cukup asli:

[source,solidity]
----
function isContract(address _addr) private view returns (bool is_contract) {
  uint length;
    assembly {
       // ambil saiz kod pada alamat sasaran; ini memerlukan pemasangan
       length := extcodesize(_addr)
    }
    return (length>0);
}
----

[[ERC223_interface]]
Spesifikasi antaramuka kontrak ERC223 ialah:

[source,solidity]
----
interface ERC223Token {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);

  function name() public view returns (string _name);
  function symbol() public view returns (string _symbol);
  function decimals() public view returns (uint8 _decimals);
  function totalSupply() public view returns (uint256 _supply);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback)
      public returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value,
                 bytes indexed data);
}
----

ERC223 tidak dilaksanakan secara meluas, dan terdapat beberapa perdebatan di https://github.com/ethereum/EIPs/issues/223[the ERC discussion] mengenai keserasian mundur dan pertukaran antara pelaksanaan perubahan pada tahap antara muka kontrak lawan dengan antaramuka pengguna. Perbahasan terus berlanjutan.

==== ERC777: Satu Standard Antaramuka Kontrak Token yang Dicadangkan

((("ERC777 token standard proposal", id="ix_10tokens-asciidoc18", range="startofrange")))((("tokens","ERC777 standard proposal", id="ix_10tokens-asciidoc19", range="startofrange")))Satu lagi cadangan untuk standard kontrak token yang lebih baik ialah https://eips.ethereum.org/EIPS/eip-777[ERC777]. Cadangan ini mempunyai beberapa matlamat, termasuk:

* Untuk menawarkan antara muka yang serasi dengan ERC20
* Untuk memindahkan token menggunakan fungsi +send+, sama dengan pemindahan ether
* Agar bersesuaian dengan ERC820 untuk pendaftaran kontrak token
* Agar membenarkan kontrak dan alamat untuk mengendalikan token yang mereka hantar melalui fungsi `tokensToSend` yang dipanggil sebelum menghantar
* Untuk membolehkan kontrak dan alamat diberitahu mengenai resit token dengan memanggil fungsi `tokensReceived` oleh penerima, dan untuk mengurangkan kebarangkalian token yang dikunci menjadi kontrak dengan menghendaki kontrak untuk menyediakan suatu fungsi pass:[<span class="keep-together"><code>tokensReceived</code></span>]
* Untuk membenarkan kontrak yang sedia ada menggunakan kontrak proksi untuk fungsi +tokensToSend+ dan +tokensReceived+
* Mengendalikan dengan cara yang sama, sama ada penghantaran ke kontrak atau EOA
* Memberi peristiwa khusus untuk meghasilkan dan membakar token
* Untuk membolehkan pengendali (pihak ketiga yang dipercayai, dimaksudkan untuk menjadi kontrak yang sah) untuk mengalihkan token bagi pihak pemegang token
* Untuk menyediakan metadata pada transaksi pemindahan token dalam medan +userData+ dan +carrierData+

Perbincangan yang berterusan mengenai ERC777 boleh didapati https://github.com/ethereum/EIPs/issues/777[on GitHub].

[[ERC777_interface]]
Spesifikasi antaramuka kontrak ERC777 ialah:

[source,solidity]
----
interface ERC777Token {
    function name() public constant returns (string);
    function symbol() public constant returns (string);
    function totalSupply() public constant returns (uint256);
    function granularity() public constant returns (uint256);
    function balanceOf(address owner) public constant returns (uint256);

    function send(address to, uint256 amount, bytes userData) public;

    function authorizeOperator(address operator) public;
    function revokeOperator(address operator) public;
    function isOperatorFor(address operator, address tokenHolder)
        public constant returns (bool);
    function operatorSend(address from, address to, uint256 amount,
                          bytes userData,bytes operatorData) public;

    event Sent(address indexed operator, address indexed from,
               address indexed to, uint256 amount, bytes userData, 
               bytes operatorData);
    event Minted(address indexed operator, address indexed to,
                 uint256 amount, bytes operatorData);
    event Burned(address indexed operator, address indexed from,
                 uint256 amount, bytes userData, bytes operatorData);
    event AuthorizedOperator(address indexed operator,
                             address indexed tokenHolder);
    event RevokedOperator(address indexed operator, address indexed tokenHolder);
}
----

[[ERC777_hooks]]
===== Cangkuk ERC777

[[ERC777TokensSender_interface]]
Perincian cangkuk (hook) pengirim token ERC777 adalah:

[source,solidity]
----
interface ERC777TokensSender {
    function tokensToSend(address operator, address from, address to,
                          uint value, bytes userData, bytes operatorData) public;
}
----

Pelaksanaan antara muka ini diperlukan untuk sebarang alamat yang ingin diberitahu, untuk mengendalikan, atau untuk menghalang debit token. Alamat yang mana kontrak melaksanakan antara muka ini mesti didaftarkan melalui ERC820, sama ada kontrak melaksanakan antara muka untuk dirinya atau alamat lain.

[[ERC777TokensRecipient_interface]]
Spesifikasi cangkuk penerima ERC777 adalah:

[source,solidity]
----
interface ERC777TokensRecipient {
  function tokensReceived(
     address operator, address from, address to,
    uint amount, bytes userData, bytes operatorData
  ) public;
}
----

Pelaksanaan antara muka ini diperlukan untuk mana-mana alamat yang ingin diberitahu, mengendalikan, atau menolak penerimaan token. Logik dan keperluan yang sama berlaku kepada penerima token tentang antara muka penghantar token, dengan kekangan tambahan yang kontrak penerima mesti melaksanakan antara muka ini untuk mengelakkan token terkunci. Jika kontrak penerima tidak mendaftar alamat yang melaksanakan antara muka ini, pemindahan token akan gagal.

Aspek penting ialah hanya satu penghantar token dan satu penerima token yang boleh didaftarkan setiap alamat. Oleh itu, bagi setiap pemindahan ERC777 token, fungsi cangkuk yang sama dipanggil debit dan penerimaan setiap pemindahan token ERC777. Token khusus boleh dikenalpasti dalam fungsi ini menggunakan pengirim mesej, iaitu alamat kontrak token khusus, untuk mengendalikan kes penggunaan tertentu.

Sebaliknya, penghantar token yang sama dan cangkuk penerima token boleh didaftarkan untuk pelbagai alamat dan cangkuk boleh membezakan siapa penghantar dan penerima yang dimaksudkan menggunakan parameter `from` dan `to`.

Pelaksanaan http://bit.ly/2qkAKba[reference] ERC777 dikaitkan dengan cadangan itu. ERC777 bergantung pada cadangan selari untuk kontrak pendaftaran, yang dinyatakan dalam ERC820. Sebahagian daripada perdebatan tentang ERC777 adalah tentang kerumitan mengguna pakai dua perubahan besar sekaligus: piawaian token baharu dan piawaian pendaftaran. Perbincangan masih berterusan. (((range="endofrange", startref="ix_10tokens-asciidoc19")))(((range="endofrange", startref="ix_10tokens-asciidoc18")))

[[erc721]]
==== ERC721: Piawaian Token (Surat Ikatan) yang tidak boleh laku

((("deed","and ERC721 non-fungible token standard", id="ix_10tokens-asciidoc20", range="startofrange")))((("ERC721 non-fungible token standard", id="ix_10tokens-asciidoc21", range="startofrange")))((("non-fungible tokens (NFTs)","ERC721 non-fungible token standard", id="ix_10tokens-asciidoc22", range="startofrange")))((("tokens","ERC721 non-fungible token standard", id="ix_10tokens-asciidoc23", range="startofrange")))Semua piawaian token yang kita lihat sejauh ini adalah untuk token _fumgible_, yakni token yang boleh ditukar ganti dan laku. Standard token ERC20 hanya menjejaki baki terakhir bagi setiap akaun dan tidak (secara jelasnya) menjejaki hasil sebarang token.

((("deed","defined")))The http://bit.ly/2Ogs7Im[ERC721 proposal] Cadangan http://bit.ly/2Ogs7Im[ERC721] adalah untuk token _non-fungible_ iaitu token tidak boleh laku, juga dikenali sebagai _deed_.

Dari Kamus Oxford:

____
_deed_: Dokumen undang-undang yang ditandatangani dan dihantar, terutama sekali mengenai pemilikan harta atau hak hukum.
____

Penggunaan perkataan "surat ikatan" (deed) bertujuan untuk mencerminkan bahagian "pemilikan harta", walaupun ini tidak dikenali sebagai "dokumen undang-undang"; dalam mana-mana bidang kuasa&#x2014;namun, kmungkinan besar pada masa akan datang, pemilikan undang-undang berdasarkan tanda tangan digital pada platform rantai blok akan diiktiraf secara sah.

Token jenis tidak fungible mengesan pemilikan sesuatu yang unik. Perkara yang dimiliki boleh menjadi barang digital, seperti barang dalam permainan atau koleksi digital; atau benda itu boleh menjadi barang fizikal yang pemilikannya dikesan oleh token, seperti rumah, kereta, atau karya seni. Perbuatan juga boleh mewakili perkara-perkara yang mempunyai nilai negatif, seperti pinjaman (hutang), tunggakan, kemudahan, dan lain-lain. Piawaian ERC721 tidak mempunyai batasan atau jangkaan tentang sifat pemilikannya yang dikesan oleh surat ikatan (deed) dan hanya memerlukannya yang dikenalpasti secara unik, yang dalam kes standard ini dicapai dengan  pass: [<span class="keep-together">pengenalpasti</span>] 256-bit.

Butiran piawaian dan perbincangan dijejaki dalam dua pass:[<span class="keep-together">lokasi</span>] Github berbeza:

* https://github.com/ethereum/EIPs/issues/721[Initial proposal]

* https://github.com/ethereum/EIPs/pull/841[Continued discussion]

[[map_deed_owner]]
Untuk memahami perbezaan asas antara ERC20 dan ERC721, adalah mencukupi untuk melihat struktur data dalaman yang digunakan dalam ERC721:

[source,solidity]
----
// Pemetaan dari pengenalan surat ikatan kepada pemilik
mapping (uint256 => address) private deedOwner;
----

Manakala ERC20 menjejaki baki milik setiap pemilik, dengan pemilik menjadi kunci utama pemetaan, ERC721 menjejaki setiap pengenalan diri surat ikatan dan siapa yang memilikinya, dengan pengenalan diri, surat ikatan menjadi kunci utama pemetaan. Dari aliran perbezaan dasar ini semua sifat token tidak boleh tukar laku.

[[ERC721_interface]]
Perincian antara muka kontrak ERC721 ialah:

[source,solidity]
----
interface ERC721 /* is ERC165 */ {
    event Transfer(address indexed _from, address indexed _to, uint256 _deedId);
    event Approval(address indexed _owner, address indexed _approved,
                   uint256 _deedId);
    event ApprovalForAll(address indexed _owner, address indexed _operator,
                         bool _approved);

    function balanceOf(address _owner) external view returns (uint256 _balance);
    function ownerOf(uint256 _deedId) external view returns (address _owner);
    function transfer(address _to, uint256 _deedId) external payable;
    function transferFrom(address _from, address _to, uint256 _deedId)
        external payable;
    function approve(address _approved, uint256 _deedId) external payable;
    function setApprovalForAll(address _operateor, boolean _approved) payable;
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
----

ERC721 juga menyokong dua antara muka _optional_, satu untuk metadata dan satu untuk penghitungan perbuatan dan pemilik.

[[ERC721_metadata]]
Antara muka pilihan ERC721 untuk metadata ialah:

[source,solidity]
----
interface ERC721Metadata /* is ERC721 */ {
    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function deedUri(uint256 _deedId) external view returns (string _deedUri);
}
----

[[ERC721_enum]]
Antara muka pilihan ERC721 untuk penghitungan ialah (((range="endofrange", startref="ix_10tokens-asciidoc23")))(((range="endofrange", startref="ix_10tokens-asciidoc22")))(((range="endofrange", startref="ix_10tokens-asciidoc21")))(((range="endofrange", startref="ix_10tokens-asciidoc20"))):(((range="endofrange", startref="ix_10tokens-asciidoc4")))

[source,solidity]
----
interface ERC721Enumerable /* is ERC721 */ {
    function totalSupply() external view returns (uint256 _count);
    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);
    function countOfOwners() external view returns (uint256 _count);
    function ownerByIndex(uint256 _index) external view returns (address _owner);
    function deedOfOwnerByIndex(address _owner, uint256 _index) external view
        returns (uint256 _deedId);
}
----

[[token_std_review]]
=== Menggunakan Piawai Token

((("token standards (generally)", seealso="specific standards, e.g.: ERC20 token standard", id="ix_10tokens-asciidoc24", range="startofrange")))((("tokens","using token standards", id="ix_10tokens-asciidoc25", range="startofrange")))Dalam bahagian sebelumnya, kami menyemak beberapa piawai yang dicadangkan dan beberapa piawaian yang digunakan secara meluas untuk kontrak token. Apakah sebenarnya piawaian ini? Haruskah anda menggunakan piawaian ini? Bagaimana hendak menggunakannya? Perlukah anda menambah fungsi di luar piawaian ini? Piawaian mana yang patut anda gunakan? Kita akan mengkaji beberapa soalan seterusnya.

[[token_std_purpose]]
==== Apakah Piawaian Token? Apakah maksud mereka?

((("token standards (generally)","defined")))Piawaian token adalah perincian _terendah_ untuk pelaksanaan. Maksudnya ialah untuk mematuhi, katakanlah, ERC20, anda perlu melaksanakan fungsi dan tingkah laku yang paling sedikit yang ditetapkan oleh piawaian ERC20 sekurang-kurangnya. Anda juga bebas untuk _menambahkan_ kepada fungsi dengan melaksanakan fungsi yang bukan sebahagian daripada piawai.

((("token standards (generally)","purpose of")))Tujuan utama piawaian ini adalah untuk menggalakkan _persaudaraan_ antara kontrak. Oleh itu, semua dompet, pengurupan, antara muka pengguna dan komponen pembinaan lain boleh _mengantaramukakan_ dalam cara yang boleh diramal dengan mana-mana kontrak yang mengikuti perinciannya. Dengan kata lain, jika anda menggunakan kontrak yang mengikut piawaian ERC20, semua pengguna dompet sedia ada dengan mudahnya boleh memulakan dagangan token anda tanpa naik taraf atau berusaha membuat tetapan dompet bagi pihak anda.

Piawaian ini dimaksudkan untuk menjadi _penghuraian_, bukan _penetapan_. Bagaimana anda memilih untuk melaksanakan fungsi tersebut adalah terpulang kepada anda&#x2014;fungsi dalaman kontrak tidak berkaitan dengan piawaiam. Ia mempunyai beberapa keperluan fungsi, yang mengawal tingkah laku di bawah keadaan tertentu, tetapi ia tidak menetapkan pelaksanaan. Contohnya ialah tingkah laku fungsi +transfer+ jika nilai ditetapkan kepada sifar.

[[should_use_std]]
==== Haruskah Anda Menggunakan Piawaian ini?

((("token standards (generally)","reasons to use")))Memandangkan semua piawaian ini, maka setiap pembangun menghadapi dilema: menggunakan piawaian sedia ada atau membuat perubahan melangkaui sekatan yang dikenakannya?

Dilema ini tidak mudah diselesaikan. Piawaian semestinya menghalang keupayaan anda untuk membuat pembaharuan, dengan mewujudkan "rentak" sempit yang perlu anda ikuti. Sebaliknya, piawaian asas telah muncul dari pengalaman dengan beratus-ratus aplikasi dan sesuai dengan kebanyakan kes penggunaan.

Sebagai sebahagian daripada pertimbangan ini adalah isu yang lebih besar: nilai kebolehoperasian dan penggunaan luas. Jika anda memilih untuk menggunakan piawaian yang sedia ada, anda akan mendapat nilai semua sistem yang direka untuk berfungsi dengan piawai itu. Jika anda memilih untuk berlepas dari piawai, anda perlu mempertimbangkan kos membina semua rangka kerja sokongan sendiri, atau memujuk orang lain untuk menyokong pelaksanaan anda sebagai piawaian baharu. Kecenderungan untuk menempa laluan anda sendiri dan mengabaikan piawaian sedia ada dikenali sebagai sindrom "Tidak Disenarai Di Sini" dan bersifat bercanggah untuk budaya sumber terbuka. Sedanhkan, kemajuan dan pembaharuan bergantung pada keluar dari tradisi. Ini pilihan yang sukar, jadi pertimbangkan dengan teliti!

[NOTA]
====
Sebagaimana dalam Wikipedia, https://en.wikipedia.org/wiki/Not_invented_here[&#x201c;Not Invented Here&#x201d;] Pendirian tidak disenarai di sini adalah pendirian yang diterima pakai oleh budaya sosial, korporat atau budaya institusi yang mengelakkan penggunaan atau pembelian produk, penyelidikan, piawaian atau pengetahuan yang sedia ada kerana kos luaran dan keaslian mereka, seperti ganjaran kesetiaan.
====


[[security_maturity]]
==== Keselamatan Berlandaskan Kematangan

((("security (smart contracts)","token standard implementation choices")))((("token standards (generally)","implementation choices")))Selain pilihan piawaian, terdapat pilihan _perlaksanaan_ yang selari. Apabila anda membuat keputusan untuk menggunakan piawaian seperti ERC20, anda perlu memutuskan cara melaksanakan reka bentuk yang serasi. Terdapat beberapa "rujukan" yang sedia ada digunakan secara meluas dalam hubung kait Ethereum, atau anda boleh menulis sendiri dari awal. Sekali lagi, pilihan ini merupakan dilema yang boleh mempunyai kesan keselamatan yang padah.

Pelaksanaan sedia ada adalah yang ada adalah &#x201c;battle-tested.&#x201d; Walaupun tidak mustahil untuk membuktikan bahawa ianya selamat, ramai di antaranya menguatkan lagi penghasilam token berjuta-juta dolar. Mereka telah diserang, berulang kali dan bersungguh-sungguh. Setakat ini, tiada kelemahan besar telah ditemui. Menulis sendiri tidaklah mudah&#x2014;ada banyak cara halus yang kontrak ini dapat disekutukan. Ia lebih selamat untuk menggunakan pelaksanaan yang telah teruji dan digunakan secara meluas. Dalam contoh kami, kami menggunakan pelaksanaan OpenZeppelin piawaian ERC20, kerana pelaksanaan ini adalah fokus keselamatan dari dasar.

Jika anda menggunakan pelaksanaan yang ada, anda juga boleh memanjangkannya. Sekali lagi, berhati-hati dengan gerak nadi ini. Kerumitan adalah musuh keselamatan.((("attack surface")))Setiap satu baris kod yang anda tambah mengembangkan lagi _serangan permukaan_ anda dan mampu mewakili kerentanan yang sedia menanti. Anda mungkin tidak perasan masalah berlaku sehinggalah anda meletakkan banyak nilai di atas kontrak dan tiba-tiba seseorang memecahkannya.

[PETUA]
====
Pilihan piawai dan pelaksanaan merupakan bahagian penting dalam reka bentuk kontrak pintar secara keseluruhan yang selamat, tetapi ia bukan satu-satunya pertimbangan. Lihat <<smart_contract_security>>.(((range="endofrange", startref="ix_10tokens-asciidoc25")))(((range="endofrange", startref="ix_10tokens-asciidoc24")))
====


[[extend_token_interface]]
=== Sambungan untuk Piawaian Antara Muka Token

((("token standards (generally)","extensions to")))Piawaian token dibincangkan dalam bab ini menyediakan antara muka yang sangat ringkas, dengan fungsi yang terhad. Banyak projek telah mewujudkan pelaksanaan lanjutan untuk menyokong ciri-ciri yang mereka perlukan bagi aplikasi mereka. Antara ciri-ciri ini termasuk:

Kawalan pemilik:: Keupayaan untuk memberikan alamat tertentu atau set alamat (iaitu, skim multisig), keupayaan istimewa, seperti senarai hitam, senarai putih, kilang duit, pemulihan, dll.

Pembakaran:: Keupayaan untuk sengaja memusnahkan (&#x201c;burn&#x201d;) dengan memindahkannya ke alamat yang tidak dapat dibelanjakan lagi atau dengan menghapuskan alamat tidak boleh dibelanjakan dan mengurangkan bekalan.

Minting:: Keupayaan untuk menambah jumlah bekalan token, pada kadar yang boleh diramal atau oleh "fiat" pencipta token.

Crowdfunding:: Keupayaan untuk menawarkan token untuk dijual, contohnya melalui lelongan, penjualan pasaran, lelongan balik, dll.

Caps:: Keupayaan untuk menetapkan had yang ditetapkan dan tidak berubah pada jumlah bekalan (bertentangan dengan ciri kilang duit "minting").

Recovery Backdoors:: Fungsi untuk memulihkan dana, memulihkan pindahan, atau membongkar token yang boleh diaktifkan oleh alamat atau set alamat yang ditetapkan.

Whitelisting:: Keupayaan untuk menyekat tindakan (seperti pemindahan token) ke alamat tertentu. Paling biasa digunakan untuk menawarkan token kepada "pelabur terhormat" selepas membuat pemeriksaan oleh peraturan-peraturan yang berbeza bidang kuasa. Biasanya terdapat alat kerja untuk mengemaskini senarai putih.

Senarai hitam:: Keupayaan untuk menyekat pemindahan token dengan melarang alamat tertentu. Biasanya terdapat fungsi untuk mengemas kini senarai hitam.

Terdapat pelaksanaan rujukan untuk banyak fungsi ini, contohnya dalam pustaka OpenZeppelin. Sesetengahnya menggunakan kes khusus dan hanya dilaksanakan dalam beberapa token. Hari ini, tiada piawaian yang diterima secara meluas untuk antara muka dengan fungsi ini.

Seperti yang telah dibincangkan sebelum ini, keputusan untuk memperluaskan piawaian token dengan fungsi tambahan merupakan pertukaran antara perubahan/risiko dan boleh saling operasi/keselamatan.

[[tokens_ico]]
=== Token dan ICO

((("Initial Coin Offerings (ICOs)","tokens and")))((("tokens","ICOs and")))Token telah menjadi bahan lesakan dalam hubung kait Ethereum. Ia mungkin akan menjadi alat penting dalam semua platform kontrak pintar seperti Ethereum.

Walau bagaimanapun, kesan kepentingan dan masa depan piawaian ini tidak harus dikelirukan dengan pengesahan penawaran token semasa. Seperti mana-mana teknologi peringkat awal, gelombang pertama produk dan syarikat akan hampir gagal, dan beberapa akan gagal secara beransur-ansur. Banyak token yang ditawarkan di Ethereum hari ini menyebabkan penipuan, skim piramid, dan cengkaman wang.

Caranya ialah memisahkan wawasan jangka panjang dan impak teknologi ini, yang mungkin kian mengembang, kepada gelembung ICO token jangka pendek, yang berakar dengan penipuan. Token pialwai dan platform hanya akan bertahan pada peminat token semasa, dan kemudian mereka mungkin akan mengubah dunia.

=== Kesimpulan

Token adalah konsep yang sangat kuat dalam Ethereum dan boleh menjadi asas kepada banyak aplikasi penting yang bukan terpusat. Dalam bab ini kita melihat pelbagai jenis token dan piawaian token, dan anda membina aplikasi token pertama dan berkaitan anda. Kita akan mengulang kembali hal token di <<decentralized_applications_chap>> di mana anda akan menggunakan token tidak fungible sebagai asas untuk lelongan DApp.(((range="endofrange", startref="ix_10tokens-asciidoc0")))